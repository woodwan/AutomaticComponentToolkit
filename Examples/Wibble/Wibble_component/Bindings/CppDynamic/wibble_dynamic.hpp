/*++

Copyright (C) 2019 Autodesk

All rights reserved.

This file has been generated by the Automatic Component Toolkit (ACT) version 1.6.0-RC1.

Abstract: This is an autogenerated C++-Header file in order to allow an easy
 use of Wibble

Interface version: 0.0.1

*/

#ifndef __WIBBLE_CPPHEADER_DYNAMIC_CPP
#define __WIBBLE_CPPHEADER_DYNAMIC_CPP

#include "wibble_types.hpp"
#include "wibble_dynamic.h"


#ifdef _WIN32
#include <windows.h>
#else // _WIN32
#include <dlfcn.h>
#endif // _WIN32
#include <string>
#include <memory>
#include <vector>
#include <exception>

namespace Wibble {

/*************************************************************************************************************************
 Forward Declaration of all classes
**************************************************************************************************************************/
class CWrapper;
class CBase;

/*************************************************************************************************************************
 Declaration of deprecated class types
**************************************************************************************************************************/
typedef CWrapper CWibbleWrapper;
typedef CBase CWibbleBase;

/*************************************************************************************************************************
 Declaration of shared pointer types
**************************************************************************************************************************/
typedef std::shared_ptr<CWrapper> PWrapper;
typedef std::shared_ptr<CBase> PBase;

/*************************************************************************************************************************
 Declaration of deprecated shared pointer types
**************************************************************************************************************************/
typedef PWrapper PWibbleWrapper;
typedef PBase PWibbleBase;


/*************************************************************************************************************************
 Class EWibbleException 
**************************************************************************************************************************/
class EWibbleException : public std::exception {
protected:
  /**
  * Error code for the Exception.
  */
  WibbleResult m_errorCode;
  /**
  * Error message for the Exception.
  */
  std::string m_errorMessage;

public:
  /**
  * Exception Constructor.
  */
  EWibbleException(WibbleResult errorCode, const std::string & sErrorMessage)
    : m_errorMessage("Wibble Error " + std::to_string(errorCode) + " (" + sErrorMessage + ")")
  {
    m_errorCode = errorCode;
  }

  /**
  * Returns error code
  */
  WibbleResult getErrorCode() const noexcept
  {
    return m_errorCode;
  }

  /**
  * Returns error message
  */
  const char* what() const noexcept
  {
    return m_errorMessage.c_str();
  }

};

/*************************************************************************************************************************
 Class CInputVector
**************************************************************************************************************************/
template <typename T>
class CInputVector {
private:
  
  const T* m_data;
  size_t m_size;
  
public:
  
  CInputVector( const std::vector<T>& vec)
    : m_data( vec.data() ), m_size( vec.size() )
  {
  }
  
  CInputVector( const T* in_data, size_t in_size)
    : m_data( in_data ), m_size(in_size )
  {
  }
  
  const T* data() const
  {
    return m_data;
  }
  
  size_t size() const
  {
    return m_size;
  }
  
};

// declare deprecated class name
template<typename T>
using CWibbleInputVector = CInputVector<T>;

/*************************************************************************************************************************
 Class CWrapper 
**************************************************************************************************************************/
class CWrapper {
public:
  
  CWrapper(void* pSymbolLookupMethod)
  {
    CheckError(nullptr, initWrapperTable(&m_WrapperTable));
    CheckError(nullptr, loadWrapperTableFromSymbolLookupMethod(&m_WrapperTable, pSymbolLookupMethod));
    
    CheckError(nullptr, checkBinaryVersion());
  }
  
  CWrapper(const std::string &sFileName)
  {
    CheckError(nullptr, initWrapperTable(&m_WrapperTable));
    CheckError(nullptr, loadWrapperTable(&m_WrapperTable, sFileName.c_str()));
    
    CheckError(nullptr, checkBinaryVersion());
  }
  
  static PWrapper loadLibrary(const std::string &sFileName)
  {
    return std::make_shared<CWrapper>(sFileName);
  }
  
  static PWrapper loadLibraryFromSymbolLookupMethod(void* pSymbolLookupMethod)
  {
    return std::make_shared<CWrapper>(pSymbolLookupMethod);
  }
  
  ~CWrapper()
  {
    releaseWrapperTable(&m_WrapperTable);
  }
  
  inline void CheckError(CBase * pBaseClass, WibbleResult nResult);


private:
  sWibbleDynamicWrapperTable m_WrapperTable;
  
  WibbleResult checkBinaryVersion()
  {
    Wibble_uint32 nMajor, nMinor, nMicro;
    (nMajor, nMinor, nMicro);
    if ( (nMajor != WIBBLE_VERSION_MAJOR) || (nMinor < WIBBLE_VERSION_MINOR) ) {
      return WIBBLE_ERROR_INCOMPATIBLEBINARYVERSION;
    }
    return WIBBLE_SUCCESS;
  }
  WibbleResult initWrapperTable(sWibbleDynamicWrapperTable * pWrapperTable);
  WibbleResult releaseWrapperTable(sWibbleDynamicWrapperTable * pWrapperTable);
  WibbleResult loadWrapperTable(sWibbleDynamicWrapperTable * pWrapperTable, const char * pLibraryFileName);
  WibbleResult loadWrapperTableFromSymbolLookupMethod(sWibbleDynamicWrapperTable * pWrapperTable, void* pSymbolLookupMethod);

  friend class CBase;

};


/*************************************************************************************************************************
 Wrapper for interface Wibble 
**************************************************************************************************************************/

class CWibble {
public:
  
    inline CWibble(const sWibble& abi);
    inline CWibble(const CWibble& that);
    inline CWibble& operator=(const CWibble& that);
    inline ~CWibble();
  
    inline const sWibble& GetABI() const;
  
    inline void GetWobble(sWobble & );
private:
  sWibble m_abi;
};

  
  void CWibble::GetWobble(sWobble & )
  {
    CheckError(m_abi.m_vtable->m_GetWobble(m_pHandle, &));
  }

/*************************************************************************************************************************
 Wrapper for interface Wobble 
**************************************************************************************************************************/

class CWobble {
public:
  
    inline CWobble(const sWobble& abi);
    inline CWobble(const CWobble& that);
    inline CWobble& operator=(const CWobble& that);
    inline ~CWobble();
  
    inline const sWobble& GetABI() const;
  
private:
  sWobble m_abi;
};

  
/*************************************************************************************************************************
 Class CBase 
**************************************************************************************************************************/
class CBase {
public:
  
protected:
  /* Wrapper Object that created the class. */
  CWrapper * m_pWrapper;
  /* Handle to Instance in library*/
  WibbleHandle m_pHandle;

  /* Checks for an Error code and raises Exceptions */
  void CheckError(WibbleResult nResult)
  {
    if (m_pWrapper != nullptr)
      m_pWrapper->CheckError(this, nResult);
  }
public:
  /**
  * CBase::CBase - Constructor for Base class.
  */
  CBase(CWrapper * pWrapper, WibbleHandle pHandle)
    : m_pWrapper(pWrapper), m_pHandle(pHandle)
  {
  }

  /**
  * CBase::~CBase - Destructor for Base class.
  */
  virtual ~CBase()
  {
    if (m_pWrapper != nullptr)
      m_pWrapper->(this);
    m_pWrapper = nullptr;
  }

  /**
  * CBase::GetHandle - Returns handle to instance.
  */
  WibbleHandle GetHandle()
  {
    return m_pHandle;
  }
  
  friend class CWrapper;
};
  
  inline void CWrapper::CheckError(CBase * pBaseClass, WibbleResult nResult)
  {
    if (nResult != 0) {
      std::string sErrorMessage;
      if (pBaseClass != nullptr) {
        (pBaseClass, sErrorMessage);
      }
      throw EWibbleException(nResult, sErrorMessage);
    }
  }
  

  inline WibbleResult CWrapper::initWrapperTable(sWibbleDynamicWrapperTable * pWrapperTable)
  {
    if (pWrapperTable == nullptr)
      return WIBBLE_ERROR_INVALIDPARAM;
    
    pWrapperTable->m_LibraryHandle = nullptr;
    
    return WIBBLE_SUCCESS;
  }

  inline WibbleResult CWrapper::releaseWrapperTable(sWibbleDynamicWrapperTable * pWrapperTable)
  {
    if (pWrapperTable == nullptr)
      return WIBBLE_ERROR_INVALIDPARAM;
    
    if (pWrapperTable->m_LibraryHandle != nullptr) {
    #ifdef _WIN32
      HMODULE hModule = (HMODULE) pWrapperTable->m_LibraryHandle;
      FreeLibrary(hModule);
    #else // _WIN32
      dlclose(pWrapperTable->m_LibraryHandle);
    #endif // _WIN32
      return initWrapperTable(pWrapperTable);
    }
    
    return WIBBLE_SUCCESS;
  }

  inline WibbleResult CWrapper::loadWrapperTable(sWibbleDynamicWrapperTable * pWrapperTable, const char * pLibraryFileName)
  {
    if (pWrapperTable == nullptr)
      return WIBBLE_ERROR_INVALIDPARAM;
    if (pLibraryFileName == nullptr)
      return WIBBLE_ERROR_INVALIDPARAM;
    
    #ifdef _WIN32
    // Convert filename to UTF16-string
    int nLength = (int)strlen(pLibraryFileName);
    int nBufferSize = nLength * 2 + 2;
    std::vector<wchar_t> wsLibraryFileName(nBufferSize);
    int nResult = MultiByteToWideChar(CP_UTF8, 0, pLibraryFileName, nLength, &wsLibraryFileName[0], nBufferSize);
    if (nResult == 0)
      return WIBBLE_ERROR_COULDNOTLOADLIBRARY;
    
    HMODULE hLibrary = LoadLibraryW(wsLibraryFileName.data());
    if (hLibrary == 0) 
      return WIBBLE_ERROR_COULDNOTLOADLIBRARY;
    #else // _WIN32
    void* hLibrary = dlopen(pLibraryFileName, RTLD_LAZY);
    if (hLibrary == 0) 
      return WIBBLE_ERROR_COULDNOTLOADLIBRARY;
    dlerror();
    #endif // _WIN32
    
    pWrapperTable->m_LibraryHandle = hLibrary;
    return WIBBLE_SUCCESS;
  }

  inline WibbleResult CWrapper::loadWrapperTableFromSymbolLookupMethod(sWibbleDynamicWrapperTable * pWrapperTable, void* pSymbolLookupMethod)
{
    if (pWrapperTable == nullptr)
      return WIBBLE_ERROR_INVALIDPARAM;
    if (pSymbolLookupMethod == nullptr)
      return WIBBLE_ERROR_INVALIDPARAM;
    
    typedef WibbleResult(*SymbolLookupType)(const char*, void**);
    
    SymbolLookupType pLookup = (SymbolLookupType)pSymbolLookupMethod;
    
    WibbleResult eLookupError = WIBBLE_SUCCESS;
    return WIBBLE_SUCCESS;
}

  
  
  /**
   * Method definitions for class CBase
   */

} // namespace Wibble

#endif // __WIBBLE_CPPHEADER_DYNAMIC_CPP

